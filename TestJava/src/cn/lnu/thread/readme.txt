//实现Runnable接口的好处：
1，避免了继承Thread类的单继承问题的局限性
2，Runnable接口的更符合面向对象的思想，将线程单独进行了对象的封装
3，Runnable接口的出现，降低了线程对象与线程任务之家的耦合性
4，实现Runnable接口，更便于多线程下的数据的共享


//多线程的安全问题

//产生线程安全的原因：
1，线程任务中有处理到共享的数据。
2，线程任务中有多条对共享数据的操作，一个线程在操作共享数据的过程中，其他线程参与了运算，造成了数据的错误

//解决线程安全的思想：
只要保证多条操作共享数据的代码在某一时间段，被一条线程所执行，在执行期间不允许其他线程参与运算。

//如何保证？
使用同步代码块
synchronized(对象)
{
	//需要被同步的代码
}
同步在目前情况下保证了一次只能有一个线程在执行，其他线程进不来，这就是同步的锁机制
好处：解决了多线程的安全问题
坏处：降低了执行效率

有可能出现这样一种情况：
多线程问题出现后，并且也加入了同步机制，但是线程安全问题依然存在！
这时，肯定是同步出现了问题

如何解决，需要遵守同步的前提

同步的前提：
	多个线程在同步中必须使用同一把锁，这才是对多个线程的同步
	
分析多线程是否存在安全隐患：
1,线程任务中是否存在共享数据
2，是否多条操作共享数据的代码

同步函数，其实就是在函数上加上同步关键字synchronized进行修饰
同步表现形式有两种： 1,同步代码块，2，同步函数

同步函数使用的锁是什么？this，静态类使用类本身的字节码文件对象


//多线程间的通信，多个线程都在处理同一资源，但是处理的任务却不一样
生产者-消费者

//info与newinfo包是测试多线程通信的案例，主要是使用生产者与消费者这个模型，包括单生产者单消费者以及多生产者多消费者不同的案例
info包中使用的是synchronized同步以及锁自己的监视器函数实现生产者与消费者模型，效率有点低，主要是唤醒时会唤醒本方线程浪费资源，而newinfo包是使用Lock接口以及Condition接口实现多生产者与多消费者直接的同步，使用Lock接口的newCondition()方法实现监视器与Lock锁的绑定，来监视线程的状态，从而控制多线程的同步；synchronized同步不存在这个绑定的问题，因为任何对象都可作为锁，并且锁和监视器函数wait(),notify()，notifyAll()都在这个锁对象中，而lock锁机制是锁与监视器Condition分离，需要将监视器手动绑定到lock锁上，并且一个lock锁可以绑定多个监视器，这才是它真正强大的地方。
